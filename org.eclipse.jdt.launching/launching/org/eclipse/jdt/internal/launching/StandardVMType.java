package org.eclipse.jdt.internal.launching;/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved. */import java.io.File;import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.eclipse.core.runtime.IPath;import org.eclipse.core.runtime.IStatus;import org.eclipse.core.runtime.Path;import org.eclipse.core.runtime.Status;import org.eclipse.jdt.launching.AbstractVMInstallType;import org.eclipse.jdt.launching.IVMInstall;import org.eclipse.jdt.launching.LibraryLocation;/** * A VM install type for VMs the conform to the standard * JDK installion layout. */public class StandardVMType extends AbstractVMInstallType {		/**	 * The root path for the attached src	 */	private String fDefaultRootPath;		/**	 * Returns a status object indicating whether the java executable	 * could be found.	 */	protected IStatus canDetectExecutable(File installLocation) {		File java= new File(installLocation, "bin"+File.separator+"java"); //$NON-NLS-2$ //$NON-NLS-1$		File javaExe= new File(installLocation, "bin"+File.separator+"java.exe"); //$NON-NLS-2$ //$NON-NLS-1$		if (!(java.isFile() || javaExe.isFile())) {			return new Status(IStatus.ERROR, LaunchingPlugin.getUniqueIdentifier(), 0, LaunchingMessages.getString("StandardVMType.Not_a_JDK_Root;_Java_executable_was_not_found_1"), null); //$NON-NLS-1$		}		return new Status(IStatus.OK, LaunchingPlugin.getUniqueIdentifier(), 0, LaunchingMessages.getString("StandardVMType.ok_2"), null); //$NON-NLS-1$	}	/**	 * @see IVMInstallType#getName()	 */	public String getName() {		return LaunchingMessages.getString("StandardVMType.Standard_VM_3"); //$NON-NLS-1$	}		protected IVMInstall doCreateVMInstall(String id) {		return new StandardVM(this, id);	}			protected IStatus canDetectDefaultSystemLibrary(File javaHome) {		IPath path = getDefaultSystemLibrary(javaHome);		if (!path.toFile().exists()) {			return new Status(IStatus.ERROR, LaunchingPlugin.getUniqueIdentifier(), 0, LaunchingMessages.getString("StandardVMType.Not_a_JDK_root._System_library_was_not_found._1"), null); //$NON-NLS-1$		}		return new Status(IStatus.OK, LaunchingPlugin.getUniqueIdentifier(), 0, LaunchingMessages.getString("StandardVMType.ok_2"), null); //$NON-NLS-1$	}			/**	 * @see IVMInstallType#detectInstallLocation()	 */	public File detectInstallLocation() {		File javaHome= new File (System.getProperty("java.home")); //$NON-NLS-1$		if (!javaHome.exists()) {			return null;		}		if (!canDetectExecutable(javaHome).isOK()) {			return null;		}				if (!canDetectDefaultSystemLibrary(javaHome).isOK()) {			return null;		}					if (javaHome.getName().equalsIgnoreCase("jre")) { //$NON-NLS-1$			// Some JDKs with the following structure:			//    jdkx.x/jre/bin/java			//             /bin/java			// report "jdkx.x/jre" as java.home. However, we want the top-level			// "jdkx.x" directory.			File parent= new File(javaHome.getParent());			if (canDetectExecutable(parent).isOK()) {				javaHome= parent;			}			if (!canDetectDefaultSystemLibrary(javaHome).isOK()) {				return null;			}		}			if ("J9".equals(System.getProperty("java.vm.name"))) {//$NON-NLS-2$ //$NON-NLS-1$			return null;		}		return javaHome;	}	protected IPath getDefaultSystemLibrary(File installLocation) {		IPath jreLibPath= new Path(installLocation.getPath()).append("lib").append("rt.jar"); //$NON-NLS-2$ //$NON-NLS-1$		if (jreLibPath.toFile().isFile()) {			return jreLibPath;		}		return new Path(installLocation.getPath()).append("jre").append("lib").append("rt.jar"); //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$	}	protected IPath getDefaultSystemLibrarySource(File installLocation) {		File parent= installLocation.getParentFile();		if (parent != null) {			File parentsrc= new File(parent, "src.jar"); //$NON-NLS-1$			if (parentsrc.isFile()) {				setDefaultRootPath("src");//$NON-NLS-1$				return new Path(parentsrc.getPath());			}			parentsrc= new File(parent, "src.zip"); //$NON-NLS-1$			if (parentsrc.isFile()) {				setDefaultRootPath(""); //$NON-NLS-1$				return new Path(parentsrc.getPath());			}			parentsrc= new File(installLocation, "src.jar"); //$NON-NLS-1$			if (parentsrc.isFile()) {				setDefaultRootPath("src"); //$NON-NLS-1$				return new Path(parentsrc.getPath());			}						parentsrc= new File(installLocation, "src.zip"); //$NON-NLS-1$			if (parentsrc.isFile()) {				setDefaultRootPath(""); //$NON-NLS-1$				return new Path(parentsrc.getPath());			}					}		setDefaultRootPath(""); //$NON-NLS-1$		return Path.EMPTY; //$NON-NLS-1$	}	protected IPath getDefaultPackageRootPath() {		return new Path(getDefaultRootPath());	}	/**	 * @see IVMInstallType#getDefaultSystemLibraryDescription(File)	 */	public LibraryLocation[] getDefaultLibraryLocations(File installLocation) {		List extensions = getExtensionLibraries(installLocation);				LibraryLocation[] libs = new LibraryLocation[extensions.size() + 1];		libs[0] = new LibraryLocation(getDefaultSystemLibrary(installLocation),						getDefaultSystemLibrarySource(installLocation), 						getDefaultPackageRootPath());		for (int i = 0; i < extensions.size(); i++) {			libs[i + 1] = (LibraryLocation)extensions.get(i);		}		return libs;	}		/**	 * Returns a list of default extension jars that should be placed on the build	 * path and runtime classpath, by default.	 * 	 * @param installLocation 	 * @return List	 */	protected List getExtensionLibraries(File installLocation) {		File extDir = getDefaultExtensionDirectory(installLocation);		List extensions = new ArrayList();		if (extDir != null && extDir.exists() && extDir.isDirectory()) {			String[] names = extDir.list();			for (int i = 0; i < names.length; i++) {				String name = names[i];				File jar = new File(extDir, name);				if (jar.isFile()) {					int length = name.length();					if (length > 4) {						String suffix = name.substring(length - 4);						if (suffix.equalsIgnoreCase(".zip") || suffix.equalsIgnoreCase(".jar")) { //$NON-NLS-1$ //$NON-NLS-2$							try {								IPath libPath = new Path(jar.getCanonicalPath());								LibraryLocation library = new LibraryLocation(libPath, Path.EMPTY, Path.EMPTY);								extensions.add(library);							} catch (IOException e) {								LaunchingPlugin.log(e);							}						}					}				}			}		}		return extensions;	}		/**	 * Returns the default location of the extension directory, based on the given	 * install location. The resulting file may not exist, or be <code>null</code>	 * if an extension directory is not supported.	 * 	 * @param installLocation 	 * @return default extension directory or <code>null</code>	 */	protected File getDefaultExtensionDirectory(File installLocation) {		File jre = null;		if (installLocation.getName().equalsIgnoreCase("jre")) { //$NON-NLS-1$			jre = installLocation;		} else {			jre = new File(installLocation, "jre"); //$NON-NLS-1$		}		File lib = new File(jre, "lib"); //$NON-NLS-1$		File ext = new File(lib, "ext"); //$NON-NLS-1$		return ext;	}	protected String getDefaultRootPath() {		return fDefaultRootPath;	}	protected void setDefaultRootPath(String defaultRootPath) {		fDefaultRootPath = defaultRootPath;	}	/**	 * @see org.eclipse.jdt.launching.IVMInstallType#validateInstallLocation(java.io.File)	 */	public IStatus validateInstallLocation(File installLocation) {		IStatus status = canDetectExecutable(installLocation);		if (status.isOK()) {			status = canDetectDefaultSystemLibrary(installLocation);		}		return status;	}}