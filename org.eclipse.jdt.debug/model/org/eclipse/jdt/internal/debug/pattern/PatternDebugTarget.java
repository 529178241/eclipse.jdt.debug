package org.eclipse.jdt.internal.debug.pattern;import com.sun.jdi.*;import com.sun.jdi.event.ClassPrepareEvent;import com.sun.jdi.request.BreakpointRequest;import com.sun.jdi.request.EventRequest;import java.util.*;import org.eclipse.core.resources.IMarker;import org.eclipse.core.resources.IMarkerDelta;import org.eclipse.core.runtime.CoreException;import org.eclipse.debug.core.IBreakpointManager;import org.eclipse.debug.core.IDebugConstants;import org.eclipse.debug.core.model.IProcess;import org.eclipse.jdt.debug.core.IJavaDebugConstants;import org.eclipse.jdt.internal.debug.core.*;/** * Extends the JDIDebugTarget to allow for the setting * of pattern breakpoints. */public class PatternDebugTarget extends JDIDebugTarget {	/**	 * A mapping of source file names to ReferenceType objects.	 * This mapping is used to set breakpoints in files that have	 * already been loaded.  This is required becase JDI does not	 * support searching for pre-loaded classes using a pattern	 * like it does in the ClassPrepareRequest mechanism.	 */	protected Map fReferenceTypes;		private static char[] fgUpperCaseJava = new char[] {'J', 'A', 'V', 'A'};	private static char[] fgLowerCaseJava = new char[] {'j', 'a', 'v', 'a'};	public PatternDebugTarget(VirtualMachine jvm, String name, boolean supportTerminate, boolean supportDisconnect, IProcess process) {		super(jvm, name, supportTerminate, supportDisconnect, process);		fReferenceTypes= new HashMap(10);	}		/**	 * Attempts to install a deferred breakpoint	 * into the newly loaded class.	 */	protected void installDeferredBreakpoints(ClassPrepareEvent event) {		String sourceName= null;		try {			sourceName= event.referenceType().sourceName().trim();		} catch (AbsentInformationException e) {		}		if (sourceName == null || endsWithJava(sourceName)) {			super.installDeferredBreakpoints(event);			return;		}				// Only pattern breakpoints from here on.		String typeName= event.referenceType().name();		if (typeName == null)			return;		Iterator i= fDeferredBreakpointsByClass.keySet().iterator();		while(i.hasNext()) {			String pattern= (String)i.next();			if (typeName.startsWith(pattern)) {				ArrayList markers= (ArrayList) fDeferredBreakpointsByClass.get(pattern);				if (markers != null) {					Iterator itr= ((ArrayList) markers.clone()).iterator();					while (itr.hasNext()) {						IMarker marker= (IMarker) itr.next();						patternBreakpointAdded(marker);					}							}				return;			}		}	}		public void breakpointAdded(IMarker breakpoint) {		if (PatternDebugModel.isPatternBreakpoint(breakpoint)) {			patternBreakpointAdded(breakpoint);		} else {			super.breakpointAdded(breakpoint);		}	}	/**	 * Attempts to create an instance of <code>java.lang.ThreadDeath</code> in the target VM.	 * This instance will be used to terminate threads in the target VM.	 * Note that if a thread death instance is not created threads will return <code>false</code>	 * to <code>ITerminate#canTerminate()</code>.	 */	protected void createThreadDeathInstance(ThreadReference threadRef) {		/** Pattern Support		if (fThreadDeathAttempts == MAX_THREAD_DEATH_ATTEMPTS) {			if (fUniversalClassPrepareReq != null) {				try {					getEventRequestManager().deleteEventRequest(fUniversalClassPrepareReq);					fClassPrepareRequestsByClass.remove("*");				} catch (RuntimeException e) {					internalError(e);				}				fUniversalClassPrepareReq = null;			}			return;		}		*/		fThreadDeathAttempts++;		// Try to create an instance of java.lang.ThreadDeath		// NB: This has to be done when the VM is interrupted by an event		if (fThreadDeath == null) {			JDIThread jt = findThread(threadRef);			if (jt.canPerformEvaluation()) {				// invalid state to perform an evaluation				return;			}			//non NLS			List classes= jdiClassesByName("java.lang.ThreadDeath");			if (classes != null && classes.size() != 0) {				ClassType threadDeathClass= (ClassType) classes.get(0);				Method constructor= null;				try {					constructor= threadDeathClass.concreteMethodByName("<init>", "()V");				} catch (RuntimeException e) {					internalError(e);					return;				}				try {					fThreadDeath= threadDeathClass.newInstance(threadRef, constructor, new LinkedList(), ClassType.INVOKE_SINGLE_THREADED);				} catch (ClassNotLoadedException e) {					internalError(e);				} catch (InvalidTypeException e) {					internalError(e);				} catch (InvocationException e) {					internalError(e);				} catch (IncompatibleThreadStateException e) {					internalError(e);				} catch (RuntimeException e) {					internalError(e);				}				if (fThreadDeath != null) {					try {						fThreadDeath.disableCollection(); // This object is going to be used for the lifetime of the VM. 						/** Pattern Support, continue to listen to all classloads						if (fUniversalClassPrepareReq != null) {							getEventRequestManager().deleteEventRequest(fUniversalClassPrepareReq);							fClassPrepareRequestsByClass.remove("*");						} */					} catch (RuntimeException e) {						fThreadDeath= null;						internalError(e);					}				}			}		}	}		/**	 * Installs or defers the given breakpoint	 */	protected void patternBreakpointAdded(IMarker breakpoint)  {		List types= null;		String pattern = getPattern(breakpoint);		if (fReferenceTypes != null) {			types = (List)fReferenceTypes.get(breakpoint.getResource().getName());		}			if (types != null) {			// try to install			Iterator i= types.iterator();			while(i.hasNext()) {				ReferenceType type= (ReferenceType) i.next();				installLineBreakpoint(breakpoint, type);			}		}		defer(breakpoint, pattern);	}		/**	 * A class has been loaded.  	 * Attempt to install any applicable deferred breakpoints.	 * Attempt to create a ThreadDeath instance if required.	 */	protected void handleClassLoad(ClassPrepareEvent event) {		registerClass(event);		super.handleClassLoad(event);	}		/**	 * Adds the source name and reference type to 	 * the <code>fReferenceType</code> list.  Since	 * multiple reference types can exist for one source file, 	 * we must be careful to hold onto all of them.	 */	protected void registerClass(ClassPrepareEvent event) {		ReferenceType type= event.referenceType();		String sourceName= null;		try {			sourceName= type.sourceName().trim();		} catch (AbsentInformationException e) {			return;		}		if(!endsWithJava(sourceName)) {			List list= (List)fReferenceTypes.get(sourceName);			if (list == null) {				list= new ArrayList(4);				fReferenceTypes.put(sourceName, list);			}							list.add(type);			}	}				protected String getPattern(IMarker breakpoint) {		try {			return (String)breakpoint.getAttribute(PatternDebugModel.PATTERN);		} catch (CoreException e) {		}		return null;	}		protected void uninstallAllBreakpoints() {		super.uninstallAllBreakpoints();		fReferenceTypes.clear();	}		/**	 * Since we are listening to all classloads,	 * we should not make any more class prepare requests.	 */		protected void defer(IMarker breakpoint, String typeName) {		if (!PatternDebugModel.isPatternBreakpoint(breakpoint)) {			super.defer(breakpoint, typeName);			return;		}		List bps= (List) fDeferredBreakpointsByClass.get(typeName);		if (bps == null) {			// listen for the load of the type			/** NOTE: Do not listen for typeName + "$*" since JDI			    will given $* classes without asking */			//listenForClassLoad(typeName);			bps= new ArrayList(1);			fDeferredBreakpointsByClass.put(typeName, bps);		}		bps.add(breakpoint);	}	/**	 * Returns whether the given name ends with ".java",	 * ignoring upper/lower case.	 */	protected boolean endsWithJava(String name) {		int length = name.length();		if (length >= 5) {			int pos = length - 5;			if (name.charAt(pos) == '.') {				for (int i = 0; i < fgUpperCaseJava.length; i++) {					pos++;					if (!(name.charAt(pos) == fgLowerCaseJava[i] || name.charAt(pos) == fgUpperCaseJava[i])) {						return false;					}				}				return true;			}		}		return false;	}}