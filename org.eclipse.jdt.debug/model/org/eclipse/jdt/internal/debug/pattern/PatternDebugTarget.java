package org.eclipse.jdt.internal.debug.pattern;import com.sun.jdi.*;import com.sun.jdi.event.ClassPrepareEvent;import com.sun.jdi.request.BreakpointRequest;import com.sun.jdi.request.EventRequest;import java.util.*;import org.eclipse.core.resources.IMarker;import org.eclipse.core.resources.IMarkerDelta;import org.eclipse.core.runtime.CoreException;import org.eclipse.debug.core.IDebugConstants;import org.eclipse.debug.core.model.IProcess;import org.eclipse.jdt.debug.core.IJavaDebugConstants;import org.eclipse.jdt.internal.debug.core.*;/** * Extends the JDIDebugTarget to allow for the setting * of pattern breakpoints. */public class PatternDebugTarget extends JDIDebugTarget {	/**	 * A mapping of source file names to ReferenceType objects.	 * This mapping is used to set breakpoints in files that have	 * already been loaded.  This is required becase JDI does not	 * support searching for pre-loaded classes using a pattern	 * like it does in the ClassPrepareRequest mechanism.	 */	protected Map fReferenceTypes;		protected Map fInstalledPatternBreakpoints;	public PatternDebugTarget(VirtualMachine jvm, String name, boolean supportTerminate, boolean supportDisconnect, IProcess process) {		super(jvm, name, supportTerminate, supportDisconnect, process);		fReferenceTypes= new HashMap(10);		fInstalledPatternBreakpoints= new HashMap(10);	}		/**	 * Attempts to install a deferred breakpoint	 * into the newly loaded class.	 */	protected void installDeferredBreakpoints(ClassPrepareEvent event) {		String sourceName= null;		try {			sourceName= event.referenceType().sourceName().trim();		} catch (AbsentInformationException e) {		}		if (sourceName == null || sourceName.endsWith(".java")) {			super.installDeferredBreakpoints(event);			return;		}				// Only pattern breakpoints from here on.		String typeName= event.referenceType().name();		if (typeName == null)			return;		Iterator i= fDeferredBreakpointsByClass.keySet().iterator();		while(i.hasNext()) {			String pattern= (String)i.next();			if (typeName.startsWith(pattern)) {				ArrayList markers= (ArrayList) fDeferredBreakpointsByClass.get(pattern);				if (markers != null) {					//no longer need to listen for this class load					//ClassPrepareRequest request= (ClassPrepareRequest) fClassPrepareRequestsByClass.remove(pattern);					//getEventRequestManager().deleteEventRequest(request);					Iterator itr= ((ArrayList) markers.clone()).iterator();					while (itr.hasNext()) {						IMarker marker= (IMarker) itr.next();						patternBreakpointAdded(marker);					}							}				return;			}		}	}		public void breakpointAdded(IMarker breakpoint) {		if (PatternDebugModel.isPatternBreakpoint(breakpoint)) {			patternBreakpointAdded(breakpoint);		} else {			super.breakpointAdded(breakpoint);		}	}		public void breakpointRemoved(IMarker breakpoint, IMarkerDelta delta) {		if (PatternDebugModel.isPatternBreakpoint(breakpoint)) {			patternBreakpointRemoved(breakpoint);		} else {			super.breakpointRemoved(breakpoint, delta);		}	}		/**	 * Installs or defers the given breakpoint	 */	protected void patternBreakpointAdded(IMarker breakpoint)  {		List types= null;		String pattern = getPattern(breakpoint);		if (fReferenceTypes != null) {			types = (List)fReferenceTypes.get(breakpoint.getResource().getName());		}			if (types == null || types.isEmpty()) {			defer(breakpoint, pattern);		} else {			// try to install			Iterator i= types.iterator();			while(i.hasNext()) {				ReferenceType type= (ReferenceType) i.next();				if (!installLineBreakpoint(breakpoint, type)) {					// install did not succeed - could be an inner type not yet loaded					defer(breakpoint, pattern);				}			}		}	}		/**	 * Attempts to create an instance of <code>java.lang.ThreadDeath</code> in the target VM.	 * This instance will be used to terminate threads in the target VM.	 * Note that if a thread death instance is not created threads will return <code>false</code>	 * to <code>ITerminate#canTerminate()</code>.	 */	protected void createThreadDeathInstance(ThreadReference threadRef) {		/** Pattern Support		if (fThreadDeathAttempts == MAX_THREAD_DEATH_ATTEMPTS) {			if (fUniversalClassPrepareReq != null) {				try {					getEventRequestManager().deleteEventRequest(fUniversalClassPrepareReq);					fClassPrepareRequestsByClass.remove("*");				} catch (RuntimeException e) {					internalError(e);				}				fUniversalClassPrepareReq = null;			}			return;		}		*/		fThreadDeathAttempts++;		// Try to create an instance of java.lang.ThreadDeath		// NB: This has to be done when the VM is interrupted by an event		if (fThreadDeath == null) {			JDIThread jt = findThread(threadRef);			if (jt.canPerformEvaluation()) {				// invalid state to perform an evaluation				return;			}			//non NLS			List classes= jdiClassesByName("java.lang.ThreadDeath");			if (classes != null && classes.size() != 0) {				ClassType threadDeathClass= (ClassType) classes.get(0);				Method constructor= null;				try {					constructor= threadDeathClass.concreteMethodByName("<init>", "()V");				} catch (RuntimeException e) {					internalError(e);					return;				}				try {					fThreadDeath= threadDeathClass.newInstance(threadRef, constructor, new LinkedList(), ClassType.INVOKE_SINGLE_THREADED);				} catch (ClassNotLoadedException e) {					internalError(e);				} catch (InvalidTypeException e) {					internalError(e);				} catch (InvocationException e) {					internalError(e);				} catch (IncompatibleThreadStateException e) {					internalError(e);				} catch (RuntimeException e) {					internalError(e);				}				if (fThreadDeath != null) {					try {						fThreadDeath.disableCollection(); // This object is going to be used for the lifetime of the VM. 						/** Pattern Support, continue to listen to all classloads						if (fUniversalClassPrepareReq != null) {							getEventRequestManager().deleteEventRequest(fUniversalClassPrepareReq);							fClassPrepareRequestsByClass.remove("*");						} */					} catch (RuntimeException e) {						fThreadDeath= null;						internalError(e);					}				}			}		}	}		/**	 * A class has been loaded.  	 * Attempt to install any applicable deferred breakpoints.	 * Attempt to create a ThreadDeath instance if required.	 */	protected void handleClassLoad(ClassPrepareEvent event) {		registerClass(event);		super.handleClassLoad(event);	}		/**	 * Adds the source name and reference type to 	 * the <code>fReferenceType</code> list.  Since	 * multiple reference types can exist for one source file, 	 * we must be careful to hold onto all of them.	 */	protected void registerClass(ClassPrepareEvent event) {		ReferenceType type= event.referenceType();		String sourceName= null;		try {			sourceName= type.sourceName().trim();		} catch (AbsentInformationException e) {			return;		}		if(!sourceName.endsWith(".java")) {			List list= (List)fReferenceTypes.get(sourceName);			if (list == null) {				list= new ArrayList(4);				fReferenceTypes.put(sourceName, list);			}							list.add(type);			}	}				protected String getPattern(IMarker breakpoint) {		try {			return (String)breakpoint.getAttribute(PatternDebugModel.PATTERN);		} catch (CoreException e) {		}		return null;	}		protected void patternBreakpointRemoved(IMarker breakpoint) {		// one-to-many relationship between breakpoints and requests.		List requests= (List)fInstalledPatternBreakpoints.remove(breakpoint);		if (requests == null) {			//deferred breakpoint			if (!breakpoint.exists()) {				//resource no longer exists				return;			}			String pattern= getPattern(breakpoint);			if (pattern == null) {				internalError(ERROR_BREAKPOINT_NO_TYPE);				return;			}			List markers= (List) fDeferredBreakpointsByClass.get(pattern);			if (markers == null) {				return;			}			markers.remove(breakpoint);			if (markers.isEmpty()) {				fDeferredBreakpointsByClass.remove(pattern);			}		} else {			//installed breakpoints			Iterator i= requests.iterator(); 			while(i.hasNext()) {				BreakpointRequest request= (BreakpointRequest)i.next();				try {					// cannot delete an expired request					if (!isExpired(request)) {						getEventRequestManager().deleteEventRequest(request); // disable & remove					}				} catch (VMDisconnectedException e) {					return;				} catch (RuntimeException e) {					internalError(e);				}			}		}	}		/**	 * Creates, installs, and returns a line breakpoint request at	 * the given location for the given breakpoint.	 * 	 * Since the JSP page support allows many of the same class to	 * be running, we must keep a one-to-many map of the breakpoint	 * requests.	 */	protected BreakpointRequest createLineBreakpointRequest(Location location, IMarker breakpoint) {		if (!PatternDebugModel.isPatternBreakpoint(breakpoint)) {			return super.createLineBreakpointRequest(location, breakpoint);		}		BreakpointRequest request = null;		try {			request= getEventRequestManager().createBreakpointRequest(location);			request.putProperty(IDebugConstants.BREAKPOINT_MARKER, breakpoint);			List requests= (List)fInstalledPatternBreakpoints.get(breakpoint);			if (requests == null) {				requests= new ArrayList(4);				fInstalledPatternBreakpoints.put(breakpoint, requests);			}			requests.add(request);			int hitCount= DebugJavaUtils.getHitCount(breakpoint);			if (hitCount > 0) {				request.addCountFilter(hitCount);				request.putProperty(IJavaDebugConstants.HIT_COUNT, new Integer(hitCount));				request.putProperty(IJavaDebugConstants.EXPIRED, Boolean.FALSE);			} 			request.setEnabled(getBreakpointManager().isEnabled(breakpoint));			request.setSuspendPolicy(EventRequest.SUSPEND_EVENT_THREAD);		} catch (VMDisconnectedException e) {			List requests= (List)fInstalledPatternBreakpoints.get(breakpoint);			requests.remove(request);			return null;		} catch (RuntimeException e) {			List requests= (List)fInstalledPatternBreakpoints.get(breakpoint);			requests.remove(request);			internalError(e);			return null;		}		return request;	}		protected void uninstallAllBreakpoints() {		super.uninstallAllBreakpoints();		fInstalledPatternBreakpoints.clear();		fReferenceTypes.clear();	}	}