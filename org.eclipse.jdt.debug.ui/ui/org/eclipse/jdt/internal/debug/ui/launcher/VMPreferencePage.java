package org.eclipse.jdt.internal.debug.ui.launcher;/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved. */import java.io.File;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import org.eclipse.core.resources.IProject;import org.eclipse.core.resources.IncrementalProjectBuilder;import org.eclipse.core.resources.ResourcesPlugin;import org.eclipse.core.runtime.CoreException;import org.eclipse.core.runtime.IProgressMonitor;import org.eclipse.core.runtime.IStatus;import org.eclipse.core.runtime.Status;import org.eclipse.core.runtime.SubProgressMonitor;import org.eclipse.jdt.core.IJavaModel;import org.eclipse.jdt.core.IJavaProject;import org.eclipse.jdt.core.JavaCore;import org.eclipse.jdt.core.JavaModelException;import org.eclipse.jdt.debug.ui.IJavaDebugUIConstants;import org.eclipse.jdt.internal.debug.ui.ExceptionHandler;import org.eclipse.jdt.internal.debug.ui.IJavaDebugHelpContextIds;import org.eclipse.jdt.internal.debug.ui.JDIDebugUIPlugin;import org.eclipse.jdt.internal.debug.ui.SWTUtil;import org.eclipse.jdt.launching.IVMInstall;import org.eclipse.jdt.launching.IVMInstallChangedListener;import org.eclipse.jdt.launching.IVMInstallType;import org.eclipse.jdt.launching.JavaRuntime;import org.eclipse.jdt.launching.LibraryLocation;import org.eclipse.jdt.launching.PropertyChangeEvent;import org.eclipse.jface.dialogs.ErrorDialog;import org.eclipse.jface.dialogs.ProgressMonitorDialog;import org.eclipse.jface.preference.PreferencePage;import org.eclipse.jface.viewers.CheckStateChangedEvent;import org.eclipse.jface.viewers.CheckboxTableViewer;import org.eclipse.jface.viewers.DoubleClickEvent;import org.eclipse.jface.viewers.ICheckStateListener;import org.eclipse.jface.viewers.IDoubleClickListener;import org.eclipse.jface.viewers.ISelectionChangedListener;import org.eclipse.jface.viewers.IStructuredSelection;import org.eclipse.jface.viewers.SelectionChangedEvent;import org.eclipse.jface.viewers.TableLayout;import org.eclipse.jface.viewers.Viewer;import org.eclipse.jface.viewers.ViewerSorter;import org.eclipse.swt.SWT;import org.eclipse.swt.events.ControlAdapter;import org.eclipse.swt.events.ControlEvent;import org.eclipse.swt.graphics.Point;import org.eclipse.swt.graphics.Rectangle;import org.eclipse.swt.layout.GridData;import org.eclipse.swt.layout.GridLayout;import org.eclipse.swt.widgets.Button;import org.eclipse.swt.widgets.Composite;import org.eclipse.swt.widgets.Control;import org.eclipse.swt.widgets.Event;import org.eclipse.swt.widgets.Listener;import org.eclipse.swt.widgets.Table;import org.eclipse.swt.widgets.TableColumn;import org.eclipse.ui.IWorkbench;import org.eclipse.ui.IWorkbenchPreferencePage;import org.eclipse.ui.actions.WorkspaceModifyOperation;import org.eclipse.ui.help.WorkbenchHelp;/* * The page for setting the default Java runtime preference. */public class VMPreferencePage extends PreferencePage implements IWorkbenchPreferencePage,																	IAddVMDialogRequestor {		private CheckboxTableViewer fVMList;	private Button fAddButton;	private Button fRemoveButton;	private Button fEditButton;		private IVMInstallType[] fVMTypes;	private List fVMStandins;	private List fRemovedVMs;	public VMPreferencePage() {		super();		setDescription(LauncherMessages.getString("vmPreferencePage.message")); //$NON-NLS-1$	}	/**	 * @see IWorkbenchPreferencePage#init(IWorkbench)	 */	public void init(IWorkbench workbench) {	}		private List createFakeVMInstalls(IVMInstallType[] vmTypes) {		ArrayList vms= new ArrayList();		for (int i= 0; i < vmTypes.length; i++) {			IVMInstall[] vmInstalls= vmTypes[i].getVMInstalls();			for (int j= 0; j < vmInstalls.length; j++) {				vms.add(new VMStandin(vmInstalls[j]));			}		}		return vms;	}		private void initDefaultVM() {		IVMInstall realDefault= JavaRuntime.getDefaultVMInstall();		fVMStandins= createFakeVMInstalls(fVMTypes);		fVMList.setInput(fVMStandins);		if (realDefault != null) {			Iterator iter= fVMStandins.iterator();			while (iter.hasNext()) {				IVMInstall fakeVM= (IVMInstall)iter.next();				if (isSameVM(fakeVM, realDefault)) {					setDefaultVM(fakeVM);					break;				}			}		}	}		/**	 * @see PreferencePage#createContents(Composite)	 */	protected Control createContents(Composite ancestor) {		fVMTypes= JavaRuntime.getVMInstallTypes();		fRemovedVMs= new ArrayList();		noDefaultAndApplyButton();				Composite parent= new Composite(ancestor, SWT.NULL);		GridLayout layout= new GridLayout();		layout.numColumns= 2;		layout.marginHeight = 0;		layout.marginWidth = 0;		parent.setLayout(layout);						Table table= new Table(parent, SWT.CHECK | SWT.BORDER | SWT.MULTI | SWT.FULL_SELECTION);				GridData data= new GridData(GridData.FILL_BOTH);		table.setLayoutData(data);						table.setHeaderVisible(true);		table.setLinesVisible(true);				TableLayout tableLayout= new TableLayout();		table.setLayout(tableLayout);		TableColumn column1= new TableColumn(table, SWT.NULL);		column1.setText(LauncherMessages.getString("vmPreferencePage.jreType")); //$NON-NLS-1$			TableColumn column2= new TableColumn(table, SWT.NULL);		column2.setText(LauncherMessages.getString("vmPreferencePage.jreName")); //$NON-NLS-1$				TableColumn column3= new TableColumn(table, SWT.NULL);		column3.setText(LauncherMessages.getString("vmPreferencePage.jreLocation")); //$NON-NLS-1$		fVMList= new CheckboxTableViewer(table);				fVMList.setSorter(new ViewerSorter() {			public int compare(Viewer viewer, Object e1, Object e2) {				if ((e1 instanceof IVMInstall) && (e2 instanceof IVMInstall)) {					IVMInstall left= (IVMInstall)e1;					IVMInstall right= (IVMInstall)e2;					String leftType= left.getVMInstallType().getName();					String rightType= right.getVMInstallType().getName();					int res= leftType.compareToIgnoreCase(rightType);					if (res != 0) {						return res;					}					return left.getName().compareToIgnoreCase(right.getName());				}				return super.compare(viewer, e1, e2);			}						public boolean isSorterProperty(Object element, String property) {				return true;			}		});							fVMList.setLabelProvider(new VMLabelProvider());		fVMList.setContentProvider(new ListContentProvider(fVMList, Collections.EMPTY_LIST));				fVMList.addSelectionChangedListener(new ISelectionChangedListener() {			public void selectionChanged(SelectionChangedEvent evt) {				enableButtons();			}		});				fVMList.addCheckStateListener(new ICheckStateListener() {			public void checkStateChanged(CheckStateChangedEvent event) {				IVMInstall vm=  (IVMInstall)event.getElement();				if (event.getChecked()) {					setDefaultVM(vm);				}				fVMList.setCheckedElements(new Object[] { vm });			}		});				fVMList.addDoubleClickListener(new IDoubleClickListener() {			public void doubleClick(DoubleClickEvent e) {				editVM();			}		});				Composite buttons= new Composite(parent, SWT.NULL);		buttons.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_BEGINNING));		layout= new GridLayout();		layout.marginHeight= 0;		layout.marginWidth= 0;		buttons.setLayout(layout);				fAddButton= new Button(buttons, SWT.PUSH);		fAddButton.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));		SWTUtil.setButtonDimensionHint(fAddButton);		fAddButton.setText(LauncherMessages.getString("vmPreferencePage.add")); //$NON-NLS-1$		fAddButton.addListener(SWT.Selection, new Listener() {			public void handleEvent(Event evt) {				addVM();			}		});				fEditButton= new Button(buttons, SWT.PUSH);		fEditButton.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));		SWTUtil.setButtonDimensionHint(fEditButton);		fEditButton.setText(LauncherMessages.getString("vmPreferencePage.edit")); //$NON-NLS-1$		fEditButton.addListener(SWT.Selection, new Listener() {			public void handleEvent(Event evt) {				editVM();			}		});				fRemoveButton= new Button(buttons, SWT.PUSH);		fRemoveButton.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));		SWTUtil.setButtonDimensionHint(fRemoveButton);		fRemoveButton.setText(LauncherMessages.getString("vmPreferencePage.remove")); //$NON-NLS-1$		fRemoveButton.addListener(SWT.Selection, new Listener() {			public void handleEvent(Event evt) {				removeVMs();			}		});				fVMList.setInput(Collections.EMPTY_LIST);				configureTableResizing(parent, buttons, table, column1, column2, column3);				initDefaultVM();		enableButtons();		WorkbenchHelp.setHelp(parent, IJavaDebugHelpContextIds.JRE_PREFERENCE_PAGE);				return parent;	}	/**	 * Correctly resizes the table so no phantom columns appear	 */	protected void configureTableResizing(final Composite parent, final Composite buttons, final Table table, final TableColumn column1, final TableColumn column2, final TableColumn column3) {		parent.addControlListener(new ControlAdapter() {		    public void controlResized(ControlEvent e) {		    	Rectangle area = parent.getClientArea();			    Point preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);			    int width = area.width - 2 * table.getBorderWidth();			    if (preferredSize.y > area.height) {			     	// Subtract the scrollbar width from the total column width			     	// if a vertical scrollbar will be required			     	Point vBarSize = table.getVerticalBar().getSize();			     	width -= vBarSize.x;			    }			    width-= buttons.getSize().x;			    Point oldSize = table.getSize();			    if (oldSize.x > width) {			    	// table is getting smaller so make the columns					// smaller first and then resize the table to				    // match the client area width				    column1.setWidth(width/4);				    column2.setWidth(width/4);			    	column3.setWidth(width - (column1.getWidth() + column2.getWidth()));				    table.setSize(width, area.height);			    } else {			    	// table is getting bigger so make the table			    	// bigger first and then make the columns wider			    	// to match the client area width			      	table.setSize(width, area.height);				    column1.setWidth(width/4);				    column2.setWidth(width/4);				    column3.setWidth(width - (column1.getWidth() + column2.getWidth()));			     }		    }		});	}				/**	 * @see IAddVMDialogRequestor#isDuplicateName(IVMInstallType, String)	 */	public boolean isDuplicateName(IVMInstallType type, String name) {		for (int i= 0; i < fVMStandins.size(); i++) {			IVMInstall vm= (IVMInstall)fVMStandins.get(i);			if (vm.getVMInstallType() == type) {				if (vm.getName().equals(name)) {					return true;				}			}		}		return false;	}				private void addVM() {		AddVMDialog dialog= new AddVMDialog(this, getShell(), fVMTypes, null);		dialog.setTitle(LauncherMessages.getString("vmPreferencePage.addJRE.title")); //$NON-NLS-1$		if (dialog.open() != dialog.OK) {			return;		}		fVMList.refresh();	}		/**	 * @see IAddVMDialogRequestor#vmAdded(IVMInstall)	 */	public void vmAdded(IVMInstall vm) {		fVMStandins.add(vm);		fVMList.refresh();		if (getCurrentDefaultVM() == null) {			setDefaultVM(vm);		}	}		private void removeVMs() {		IStructuredSelection selection= (IStructuredSelection)fVMList.getSelection();		Iterator elements= selection.iterator();		while (elements.hasNext()) {			Object o= elements.next();			fRemovedVMs.add(o);			fVMStandins.remove(o);		}		fVMList.refresh();		// this is order dependent. Must first refresh to work with 		// the new state of affairs		if (getCurrentDefaultVM() == null) {			if (fVMList.getTable().getItemCount() > 0) {				setDefaultVM((IVMInstall)fVMList.getElementAt(0));			}		}	}			// editing	private void editVM() {		IStructuredSelection selection= (IStructuredSelection)fVMList.getSelection();		// assume it's length one, otherwise this will not be called		IVMInstall vm= (IVMInstall)selection.getFirstElement();		editVM(vm);	}		private void editVM(IVMInstall vm) {		AddVMDialog dialog= new AddVMDialog(this, getShell(), fVMTypes, vm);		dialog.setTitle(LauncherMessages.getString("vmPreferencePage.editJRE.title")); //$NON-NLS-1$		if (dialog.open() != dialog.OK) {			return;		}		fVMList.refresh(vm);	}			private boolean isSameVM(IVMInstall left, IVMInstall right) {		if (left == right) {			return true;		}		if (left != null && right != null) {			return left.getId().equals(right.getId());		}		return false;	}	/**	 * @see IPreferencePage#performOk()	 */	public boolean performOk() {		try {			commitVMInstalls();			JavaRuntime.saveVMConfiguration();		} catch (CoreException e) {			ExceptionHandler.handle(e, LauncherMessages.getString("vmPreferencePage.error.title"), LauncherMessages.getString("vmPreferencePage.error.exception")); //$NON-NLS-2$ //$NON-NLS-1$		}		return super.performOk();	}		private void commitVMInstalls() {		VMListener listener = new VMListener();		Set affectedProjects = new HashSet();		JavaRuntime.addVMInstallChangedListener(listener);		Map vmsToProjects = null;				if (fRemovedVMs.size() > 0) {			vmsToProjects = getVMsToProjects();		}				for (int i= 0; i < fRemovedVMs.size(); i++) {			VMStandin standin= (VMStandin)fRemovedVMs.get(i);			// determine affected projects			IVMInstall orginal = standin.getVMInstallType().findVMInstall(standin.getId());			List list = (List)vmsToProjects.get(orginal);			if (list != null) {				affectedProjects.addAll(list);			}			standin.getVMInstallType().disposeVMInstall(standin.getId());		}				for (int i= 0; i < fVMStandins.size(); i++) {			VMStandin standin= (VMStandin)fVMStandins.get(i);			standin.convertToRealVM();		}				List changed = listener.getChangedVMs();		if (changed.size() > 0) {			// determine affected projects			if (vmsToProjects == null) {				vmsToProjects = getVMsToProjects();			}			Iterator vms = changed.iterator();			while (vms.hasNext()) {				IVMInstall vm = (IVMInstall)vms.next();				List list = (List)vmsToProjects.get(vm);				if (list != null) {					affectedProjects.addAll(list);				}			}		}						IVMInstall oldDefault = JavaRuntime.getDefaultVMInstall();		IVMInstall fakeDefault= getCurrentDefaultVM();		if (fakeDefault != null) {			IVMInstallType defaultType= fakeDefault.getVMInstallType();			IVMInstall realDefault= defaultType.findVMInstall(fakeDefault.getId());			if (oldDefault == null || !oldDefault.getVMInstallType().equals(defaultType) ||			 !oldDefault.getId().equals(realDefault.getId()) || (changed.contains(realDefault))) {				// build all projects that reference the default VM, if				// the default VM has changed. If there was no default VM				// before, and now there is one, re-build all projects.				if (oldDefault == null) {					try {						IJavaProject[] proj = getJavaModel().getJavaProjects();						for (int i = 0; i < proj.length; i++) {							affectedProjects.add(proj[i]);						}					} catch (JavaModelException e) {						JDIDebugUIPlugin.log(e);					}				} else {					if (vmsToProjects == null) {						vmsToProjects = getVMsToProjects();					}										List list = (List)vmsToProjects.get(oldDefault);					if (list != null) {						affectedProjects.addAll(list);					}		 					}			 	updateDefaultVMInstall(realDefault);			 }		}				JavaRuntime.removeVMInstallChangedListener(listener);				if (affectedProjects.size() > 0) {			// only build if auto-build is on			if (ResourcesPlugin.getWorkspace().isAutoBuilding()) {				buildProjects(affectedProjects);			}		}	}		/**	 * Returns a map of VM installs to projects that reference the VMs	 */	private Map getVMsToProjects() {		HashMap map = new HashMap();		try {			IJavaProject[] projects = getJavaModel().getJavaProjects();			for (int i = 0; i < projects.length; i++) {				IJavaProject jp = projects[i];				if (jp.getProject().isOpen()) {					IVMInstall vm = JavaRuntime.getVMInstall(jp);					if (vm != null) {						List list = (List)map.get(vm);						if (list == null) {							list = new ArrayList(2);							map.put(vm, list);						}						list.add(jp);					}				}			}		} catch (CoreException e) {		}		return map;	}		protected IJavaModel getJavaModel() {		return JavaCore.create(ResourcesPlugin.getWorkspace().getRoot());	}		private void updateDefaultVMInstall(final IVMInstall newDefault) {		ProgressMonitorDialog dialog= new ProgressMonitorDialog(getShell());		try {			dialog.run(true, true, new WorkspaceModifyOperation() {				public void execute(IProgressMonitor monitor) throws InvocationTargetException{					try {						JavaRuntime.setDefaultVMInstall(newDefault, monitor);					} catch (CoreException e) {						throw new InvocationTargetException(e);					}				}			});		} catch (InterruptedException e) {			// opearation canceled by user		} catch (InvocationTargetException e) {			ExceptionHandler.handle(e, getShell(), LauncherMessages.getString("VMPreferencePage.Installed_JREs_1"), LauncherMessages.getString("VMPreferencePage.Could_not_set_classpath_variables._2")); //$NON-NLS-2$ //$NON-NLS-1$		}	}		private void buildProjects(final Set projects) {		ProgressMonitorDialog dialog= new ProgressMonitorDialog(getShell());		try {			dialog.run(true, true, new WorkspaceModifyOperation() {				public void execute(IProgressMonitor monitor) throws InvocationTargetException{					try {						Iterator iter = projects.iterator();						monitor.beginTask("", projects.size() * 100); //$NON-NLS-1$						while (iter.hasNext()) {							IProgressMonitor subMontior = new SubProgressMonitor(monitor, 100);							IProject pro = ((IJavaProject)iter.next()).getProject();							pro.build(IncrementalProjectBuilder.FULL_BUILD, subMontior);							subMontior.done();						}						monitor.done();					} catch (CoreException e) {						throw new InvocationTargetException(e);					}				}			});		} catch (InterruptedException e) {			// opearation canceled by user		} catch (InvocationTargetException e) {			ExceptionHandler.handle(e, getShell(), LauncherMessages.getString("VMPreferencePage.Installed_JREs_1"), LauncherMessages.getString("VMPreferencePage.Build_failed._1")); //$NON-NLS-1$ //$NON-NLS-2$		}	}					private IVMInstall getCurrentDefaultVM() {		Object[] checked= fVMList.getCheckedElements();		if (checked.length > 0) {			return (IVMInstall)checked[0];		}		return null;	}		private void vmSelectionChanged() {		enableButtons();	}	private void enableButtons() {		fAddButton.setEnabled(fVMTypes.length > 0);		int selectionCount= ((IStructuredSelection)fVMList.getSelection()).size();		fEditButton.setEnabled(selectionCount == 1);		fRemoveButton.setEnabled(selectionCount > 0 && selectionCount < fVMList.getTable().getItemCount());	}		private void setDefaultVM(IVMInstall vm) {		if (vm != null) {			LibraryLocation[] locations= JavaRuntime.getLibraryLocations(vm);			boolean exist = true;			for (int i = 0; i < locations.length; i++) {				exist = exist && new File(locations[i].getSystemLibraryPath().toOSString()).exists();			}			if (exist) {				fVMList.setCheckedElements(new Object[] { vm });			} else {				//VM location no longer exists				fVMList.remove(vm);				fRemovedVMs.add(vm);				fVMStandins.remove(vm);				fVMList.setChecked(JavaRuntime.getDefaultVMInstall(), true);				ErrorDialog.openError(getControl().getShell(), LauncherMessages.getString("VMPreferencePage.Installed_JREs_1"), LauncherMessages.getString("VMPreferencePage.Installed_JRE_location_no_longer_exists.__JRE_will_be_removed_2"), new Status(IStatus.ERROR, IJavaDebugUIConstants.PLUGIN_ID, IJavaDebugUIConstants.INTERNAL_ERROR, LauncherMessages.getString("VMPreferencePage.JRE_removed_3"), null)); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$				return;			}		} else {			fVMList.setCheckedElements(new Object[0]);		}	}		/**	 * @see IDialogPage#setVisible(boolean)	 */	public void setVisible(boolean visible) {		super.setVisible(visible);		if (visible) {			setTitle(LauncherMessages.getString("vmPreferencePage.title")); //$NON-NLS-1$		}	}	/**	 * Determines which VMs really changed	 */	class VMListener implements IVMInstallChangedListener {				private List fChangedVMs = new ArrayList();		private List fAddedVMs = new ArrayList();				/**		 * @see IVMInstallChangedListener#defaultVMInstallChanged(IVMInstall, IVMInstall)		 */		public void defaultVMInstallChanged(			IVMInstall previous,			IVMInstall current) {		}		/**		 * @see IVMInstallChangedListener#vmAdded(IVMInstall)		 */		public void vmAdded(IVMInstall vm) {			fAddedVMs.add(vm);		}		/**		 * @see IVMInstallChangedListener#vmChanged(PropertyChangeEvent)		 */		public void vmChanged(PropertyChangeEvent event) {			if (!event.getProperty().equals(IVMInstallChangedListener.PROPERTY_JAVADOC_LOCATION)) {				Object vm = event.getSource();				if (!fAddedVMs.contains(vm)) {					fChangedVMs.add(vm);				}			}		}		/**		 * @see IVMInstallChangedListener#vmRemoved(IVMInstall)		 */		public void vmRemoved(IVMInstall vm) {		}				/**		 * Returns a list of changed VMs, possibly empty.		 */		public List getChangedVMs() {			return fChangedVMs;		}	}}